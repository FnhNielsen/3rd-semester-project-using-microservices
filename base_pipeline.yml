### Default ###
stages:
  - build
  - deploy
  - test

variables:
  CI_CD_PRODUCTION_BRANCH: main
  CI_CD_DEVELOPMENT_BRANCH: dev
  CI_CD_RELEASE_BRANCH: release
  CI_CD_HOTFIX_BRANCH: hotfix
  CI_CD_GUIDE_URL: https://gitlab.sdu.dk/semester-project-e2021/team-12/ci-cd/-/blob/dev/README.md
  CI_CD_TEST_IMAGE_GROUP: test-image
  CI_CD_BASE_IMAGE: gitlab.sdu.dk:5050/semester-project-e2021/team-12/ci-cd/base_image:2.0.4
  CI_CD_DOCKER_IMAGE: gitlab.sdu.dk:5050/semester-project-e2021/team-12/ci-cd/docker:2.0.7
  CI_CD_KUBE_IMAGE: gitlab.sdu.dk:5050/semester-project-e2021/team-12/ci-cd/kube:1.0.10
  CI_CD_TOOL_DEBUG: "true"
  CI_CD_TAG: $CI_PIPELINE_ID
  CI_CD_KUBE_CONFIG: ""
  CI_CD_TEST_IMAGE_PRE: "test-image/"
  CI_CD_PRODUCTION_IMAGE_PRE: ""
  CI_CD_PRE_IMAGE_NAME: $CI_CD_TEST_IMAGE_PRE
  # All variables below come from Ahmad
  # https://discord.com/channels/881855784873496596/888744242720165948/907304043808948255
  DOCKER_HOST: tcp://docker:2376
  DOCKER_TLS_CERTDIR: /certs
  DOCKER_TLS_VERIFY: 1
  DOCKER_CERT_PATH: $DOCKER_TLS_CERTDIR/client

# Default
workflow:
  rules:
    # development
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_CD_DEVELOPMENT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_REF_NAME == $CI_CD_DEVELOPMENT_BRANCH
    # release
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_REF_NAME =~ /^$CI_CD_RELEASE_BRANCH/
    # hotfix
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_REF_NAME =~ /^$CI_CD_HOTFIX_BRANCH/
    # production
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_CD_PRODUCTION_BRANCH
      variables:
        CI_CD_KUBE_CONFIG: "$CI_PROJECT_DIR.tmp/CI_CD_STAGING_KUBECONFIG"
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_REF_NAME == $CI_CD_PRODUCTION_BRANCH
      variables:
        CI_CD_KUBE_CONFIG: "$CI_PROJECT_DIR.tmp/CI_CD_PRODUCTION_KUBECONFIG"
        CI_CD_TEST_IMAGE_PRE: ""
        CI_CD_PRE_IMAGE_NAME: $CI_CD_PRODUCTION_IMAGE_PRE

default:
  image: $CI_CD_BASE_IMAGE
  artifacts:
    name: job-${CI_JOB_NAME}-failed-commit-${CI_COMMIT_SHORT_SHA}
    paths:
      - ${CI_BUILDS_DIR}/${CI_PROJECT_PATH}
    exclude:
      - ${CI_BUILDS_DIR}/${CI_PROJECT_PATH}/.git
    when: on_failure
    expire_in: 8 hrs

### Rules ###
# Trigger rules
.merge_request_production:
  allow_failure: false
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_CD_PRODUCTION_BRANCH
      when: on_success

.merge_production:
  allow_failure: false
  rules:
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_REF_NAME == $CI_CD_PRODUCTION_BRANCH
      when: on_success

.except_merge_production:
  allow_failure: false
  rules:
    # development
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_CD_DEVELOPMENT_BRANCH
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_REF_NAME == $CI_CD_DEVELOPMENT_BRANCH
      when: on_success
    # release
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_REF_NAME =~ /^$CI_CD_RELEASE_BRANCH/
      when: on_success
    # hotfix
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_REF_NAME =~ /^$CI_CD_HOTFIX_BRANCH/
      when: on_success
    # production
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_CD_PRODUCTION_BRANCH
      when: on_success

.except_development:
  allow_failure: false
  rules:
    # production
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_CD_PRODUCTION_BRANCH
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_REF_NAME == $CI_CD_PRODUCTION_BRANCH
      when: on_success

.always_merge_request_production:
  allow_failure: false
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_CD_PRODUCTION_BRANCH
      when: always

.always_except_merge_production:
  allow_failure: false
  rules:
    # development
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_CD_DEVELOPMENT_BRANCH
      when: always
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_REF_NAME == $CI_CD_DEVELOPMENT_BRANCH
      when: always
    # release
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_REF_NAME =~ /^$CI_CD_RELEASE_BRANCH/
      when: always
    # hotfix
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_REF_NAME =~ /^$CI_CD_HOTFIX_BRANCH/
      when: always
    # production
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_CD_PRODUCTION_BRANCH
      when: always

.on_failure_request_production:
  allow_failure: false
  rules:
    # production
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_CD_PRODUCTION_BRANCH
      when: on_failure

# Job rules
.build:
  stage: build
  allow_failure: false

.unit:
  stage: test
  extends:
    - .except_merge_production

.acceptance:
  stage: test
  extends:
    - .merge_request_production

.integration:
  stage: test
  extends:
    - .merge_request_production

.performance:
  stage: test
  extends:
    - .merge_request_production

.deploy:
  stage: deploy
  extends:
    - .except_development

.cleanup_test_image:
  stage: .post
  extends:
    - .always_except_merge_production
  allow_failure: true

### Methods ###
.artifact:
  artifacts:
    name: job-${CI_JOB_NAME}-commit-${CI_COMMIT_SHORT_SHA}
    paths:
      - ${CI_BUILDS_DIR}/${CI_PROJECT_PATH}
    untracked: true
    expire_in: 3 hrs

.build_image:
  # Variables
  #
  # CI_CD_IMAGE_NAME: (string) [Required]
  # CI_CD_FILE_NAME: (string) [Optional]
  #   Default: Dockerfile
  # CI_CD_PATH: (string) [Optional]
  #   Default: .
  #
  image: $CI_CD_DOCKER_IMAGE
  services:
    - docker:dind
  variables:
    CI_CD_FILE_NAME: Dockerfile
    CI_CD_PATH: .
  before_script:
    - certs_check
  script:
    - if [ "${CI_PIPELINE_SOURCE}" == "push" ] && [ "${CI_COMMIT_REF_NAME}" == "${CI_CD_PRODUCTION_BRANCH}" ]; then
        for version in ${CI_COMMIT_DESCRIPTION}; do break; done;
        CI_CD_TAG=$(ci_cd_tool version normalize ${version});
      fi
    - result=$(ci_cd_tool registry exist "${CI_CD_PRE_IMAGE_NAME}${CI_CD_IMAGE_NAME}" "${CI_CD_TAG}");
      [ "${result}" == "Docker image already exist." ] && echo ${result} && exit 1
    - ci_cd_tool docker login "${CI_REGISTRY_USER}" "${CI_REGISTRY_PASSWORD}" "${CI_REGISTRY}"
    - ci_cd_tool docker create "${CI_REGISTRY_IMAGE}/${CI_CD_PRE_IMAGE_NAME}${CI_CD_IMAGE_NAME}:${CI_CD_TAG}" "${CI_CD_FILE_NAME}" "${CI_CD_PATH}"
    - ci_cd_tool docker push "${CI_REGISTRY_IMAGE}/${CI_CD_PRE_IMAGE_NAME}${CI_CD_IMAGE_NAME}:${CI_CD_TAG}"

.remove_test_image_if_exist:
  # Variable
  #
  # CI_CD_IMAGE_NAME: (string) [Required]
  #
  image: $CI_CD_DOCKER_IMAGE
  services:
    - docker:dind
  before_script:
    - certs_check
  script:
    - result=$(ci_cd_tool registry exist "${CI_CD_PRE_IMAGE_NAME}${CI_CD_IMAGE_NAME}" "${CI_CD_TAG}")
      [ "${result}" == "Docker image does not exist." ] && echo ${result} && exit 0
    - ci_cd_tool docker login "${CI_REGISTRY_USER}" "${CI_REGISTRY_PASSWORD}" "${CI_REGISTRY}"
    - ci_cd_tool registry remove "${CI_CD_PRE_IMAGE_NAME}${CI_CD_IMAGE_NAME}" "${CI_CD_TAG}"

.kube:
  # Variables
  #
  # CI_CD_KUBE_FILE: (string) [Required]
  # CI_CD_CHECK_STATUS: (json) [Required]
  #   E.g.
  #     [
  #       {"type": "deployment", "name": "t12-api"},
  #       {"type": "deployment", "name": "t12-database"},
  #     ]
  # CI_CD_CONTAINER_IMAGES: (json) [Optional]
  #   E.g.
  #     [
  #       {"type": "deployment", "container": "t12-api", "image": "api"},
  #       {"type": "deployment", "container": "t12-database", "image": "database"}
  #     ]
  # CI_CD_TIMEOUT: (string) [Optional]
  #   Default: .
  #   E.g. 5m or 10s ect..
  #
  image: $CI_CD_KUBE_IMAGE
  variables:
    CI_CD_CONTAINER_IMAGES: "[]"
    CI_CD_TIMEOUT: "3m"
  script:
    - if [ "${CI_PIPELINE_SOURCE}" == "push" ] && [ "${CI_COMMIT_REF_NAME}" == "${CI_CD_PRODUCTION_BRANCH}" ]; then
        for version in ${CI_COMMIT_DESCRIPTION}; do break; done;
        CI_CD_TAG=$(ci_cd_tool version normalize ${version});

        ci_cd_tool git tag ${CI_CD_TAG};
      fi
    - for row in $(echo "${CI_CD_CONTAINER_IMAGES}" | jq -r ".[] | @base64"); do
        _jq () { echo "${row}" | base64 -d | jq -r "$1"; };
        ci_cd_tool kube image "${CI_CD_KUBE_FILE}" "$(_jq '.type')" "$(_jq '.container')" "${CI_REGISTRY_IMAGE}/${CI_CD_PRE_IMAGE_NAME}$(_jq '.image'):${CI_CD_TAG}";
      done
    - ci_cd_tool kube apply "${CI_CD_KUBE_FILE}" "${CI_CD_KUBE_CONFIG}"
    - FAILURE_STATUS=0;
      for row in $(echo "${CI_CD_CHECK_STATUS}" | jq -r ".[] | @base64"); do
        _jq () { echo "${row}" | base64 -d | jq -r "$1"; };
        ci_cd_tool kube status "$(_jq '.type')" "$(_jq '.name')" "${CI_CD_KUBE_CONFIG}" "${CI_CD_TIMEOUT}" || FAILURE_STATUS=1;
      done;
      ci_cd_tool kube describe "${CI_CD_KUBE_FILE}" "${CI_CD_KUBE_CONFIG}";
      [ "${FAILURE_STATUS}" == 1 ] && exit 1;

### Static Jobs ###
test:check_request_title:
  # NOTE: Implement check new version is newer that the old version by using git tag from production branch
  stage: test
  extends:
    - .merge_request_production
  needs: []
  script:
    - ci_cd_tool version validate ${CI_MERGE_REQUEST_TITLE}

setup:state:
  stage: .pre
  extends:
    - .merge_request_production
  needs: []
  script:
    - echo "init_state"

cleanup:state:
  allow_failure: true
  stage: .post
  extends:
    - .always_merge_request_production
  script:
    - echo "takedown_state"
